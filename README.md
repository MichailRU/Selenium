# **Selenium - Testing with Selenium and Python**

# Поиск элементов с помощью CSS-селекторов

## Поиск по id
Предположим у элемента есть атрибут id="bullet", а значит, мы однозначно можем найти её с помощью селектора `#bullet` (знак # означает, что мы ищем по id со значением bullet).

## Поиск по tag
Чтобы найти элемент по тегу, напишите название тега в поисковой строке, как мы делали это при поиске по id (только без знака #), например, `h1`. Поиск по h1 найдёт для нас элемент с названием страницы.
Поиск по тегам не очень удобен, т.к. разработчики используют небольшое количество тегов для разметки страниц, и скорее всего, одному тегу будет соответствовать множество элементов.

## Поиск по значению атрибута
Можно найти элемент, указав название атрибута и его значение. Например, можно переписать поиск по id в следующем виде `[id="bullet"]` вместо #bullet.
Лучше использовать вариант с квадратными скобками при поиске значения атрибута для тех атрибутов, у которых нет собственных коротких команд поиска.

## Поиск по name
Этот вариант поиска является разновидностью поиска по значению атрибута и записывается так же: `[name="bullet-cat"]`. Мы выделяем этот вариант потому что он довольно часто используется, а также выделяется как отдельный вид поиска элементов в Selenium WebDriver.

## Поиск по class
Поиск по классу можно записать в виде `[class="jumbotron-heading"]`, так как class тоже является атрибутом элемента. Но раз уж классы используются практически в каждой странице при задании стилей страниц, то для них также имеется свой короткий вариант поиска: `.jumbotron-heading`. То есть мы пишем значение класса и предваряем его точкой.

## Использование потомков
Для решения этой задачи мы можем взять элемент, стоящий выше в иерархии нужного нам элемента, и написать например следующий селектор: `#post2 .title`
Здесь символ # означает, что надо искать элемент с id `post2`, пробел - что также нужно найти элемент-потомок, а ., что элемент-потомок должен иметь класс со значением `title`.
Элемент `.title` называется потомком (англ. descendant) элемента `#post2`. Потомок может находиться на любом уровне вложенности, все элементы с селектором `.title` также являются и потомками элемента #posts, хотя и расположены от него на два уровня ниже.
!Внимание. Символ пробела " " является значащим в CSS-селекторах. Это важный символ, который разделяет описание предка и потомка. Если бы мы записали селектор `#post2.title` без пробела, то такая запись означала бы, что мы хотим найти элемент, который одновременно содержит id `post2` и класс `title`. Таким образом `#post2 .title` и `#post2.title` — это разные селекторы.

## Использование дочерних элементов
В записи `#post2 > div.title` мы указали еще тег элемента `div` и уточнили, что нужно взять элемент с тегом и классом: `div.title`, который находится строго на один уровень иерархии ниже чем элемент `#post2`. Для этого используется символ >.
Элемент `#post2` в этом случае называется родителем (англ. parent) для элемента `div.title`, а элемент `div.title` называется дочерним элементом (англ. child) для элемента `#post2`. Если символа > нет, то будет выполнен поиск всех элементов `div.title` на любом уровне ниже первого элемента.
!Внимание. В данном случае символы пробела вокруг символа ">" не несут важного значения в отличие от предыдущего примера, и могут быть опущены. Запись `#post2>div.title` аналогична записи `#post2 > div.title`.

## Использование порядкового номера дочернего элемента
Запись `#posts > .item:nth-child(2) > .title` означает следующее:
псевдо-класс `:nth-child(2)` — позволяет найти второй по порядку элемент среди дочерних элементов для `#posts`. Затем с помощью конструкции `> .title` мы указываем, что нам нужен элемент `.title`, родителем которого является найденный ранее элемент `.item`.

## Использование нескольких классов
Также мы можем использовать сразу несколько классов элемента, чтобы его найти. Для этого классы записываются подряд через точку: `.title.second`


# Поиск элементов с помощью Selenium
Для поиска элементов на странице в Selenium WebDriver используются несколько стратегий, позволяющих искать по атрибутам элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. Для поиска Selenium предоставляет метод **`find_element`**, который принимает два аргумента - тип локатора и значение локатора. Существуют следующие методы поиска элементов:
- **`find_element(By.ID, value)`** — поиск по уникальному атрибуту id элемента. При исполдьзовании уникальных id вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
- **`find_element(By.CSS_SELECTOR, value)`** — поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
- **`find_element(By.XPATH, value)`** — поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
- **`find_element(By.NAME, value)`** — поиск по атрибуту name элемента;
- **`find_element(By.TAG_NAME, value)`** — поиск элемента по названию тега элемента;
- **`find_element(By.CLASS_NAME, value)`** — поиск по значению атрибута class;
- **`find_element(By.LINK_TEXT, value)`** — поиск ссылки на странице по полному совпадению;
- **`find_element(By.PARTIAL_LINK_TEXT, value)`** — поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки;
- **`find_elements(вышеуказанный локатор, value)`** — поиск нескольких элементов с формированием результата поиска в виде списка.


# Простой скрипт, который откроет простую веб-страницу и заполнит форму. 

```
import time
# webdriver это и есть набор команд для управления браузером
from selenium import webdriver
# импортируем класс By, который позволяет выбрать способ поиска элемента
from selenium.webdriver.common.by import By

# инициализируем драйвер браузера. После этой команды вы должны увидеть новое открытое окно браузера
browser = webdriver.Chrome()
# метод get сообщает браузеру, что нужно открыть сайт по указанной ссылке
browser.get('https://suninjuly.github.io/text_input_task.html')

try:
    # Метод find_element позволяет найти нужный элемент на сайте, указав путь к нему. Ищем поле для ввода текста
    textarea = driver.find_element(By.CSS_SELECTOR, '.textarea')
    # Напишем текст ответа в найденное поле
    textarea.send_keys('get()')
    # Найдем кнопку, которая отправляет введенное решение
    submit_button = driver.find_element(By.CSS_SELECTOR, '.submit-submission')
    # Скажем драйверу, что нужно нажать на кнопку. После этой команды мы должны увидеть сообщение о правильном ответе
    submit_button.click()
finally:
    time.sleep(10)
    # После выполнения всех действий мы должны не забыть закрыть окно браузера
    browser.quit()
```


# Дополнительные материалы

[Что такое красивый код, и как его писать?](https://habr.com/ru/post/266969/)
[А хотите, я расскажу вам...как строить хорошие локаторы?](http://barancev.github.io/good-locators/)
[PyTest](https://habr.com/ru/post/269759/)
[Как в Яндексе используют PyTest и другие фреймворки для функционального тестирования](https://habr.com/ru/company/yandex/blog/242795/)
